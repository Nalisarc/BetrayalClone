#+Title: Traitor
#+author: Daniel Alexander Smith
#+email: nalisarc@gmail.com
* Readme
Traitor, is a personal project to transform the board game Betrayal on the House on the Hill by Bruce Glasses
into a computer program. I started writing this for the #100daysofcode challenge. While the main program is written
in python. Due to the nature of the style of document that this is written in. You could potentially conver the code into 
any language with a bit of work.
You can build your own copy of the game by opening index.org in emacs, and running entering C-c C-v C-t.

* Licence
* TODO Characters
** Character Object
#+name: Character_Object
#+BEGIN_SRC python :noweb yes :tangle traitor/character.py 
  class Character(object):

      def __init__(self,
                   name,
                   birthday,
                   might,
                   speed,
                   knowledge,
                   sanity):

          self.name = name
          self.birthday = birthday

          #Stat lists

          self.might = might
          self.speed = speed
          self.knowledge = knowledge
          self.sanity = sanity

          #Inventory
          self.inventory = []


  <<Stat_Object>>

#+END_SRC
** Statistics
Stats are represented as dictionaries containing the following bits of info:
 * Value tuple
 * Starting Slot
 * Current Slot

Each stat contains a list of 9 possible vaules. The 0 slot of each stat is always "dead".
The remaining stats represent the number of dice that are roled for that type of roll.
The speed stat is also used to tell how many spaces a character can move per turn.
#+name: Statistic_Example
#+BEGIN_SRC python :exports code 
  might = 
#+END_SRC
There might be some confusion about what the starting and current values mean.
These reference the range tuple slot, not the actual value itself. 
#+name: Stat_Object
#+BEGIN_SRC python
  class Stat(object):

      def __init__(self, range_, current):
          self.range_ = ('dead') + range_
          self.current = current
          return None

    

#+END_SRC

** Changing Stats
Sometimes in the game your characters will take damage.
Characters have four stats, these are broken up into two different catagories:
1. Mental
   * Knowledge
   * Sanity
2. Physical
   * Might
   * Speed

If a character takes damage to a category they have the ability to chose which stat takes the damage, 
and in cases of multiple points they can divide the points up however they chose so long all the points of damage are taken.
However if damage is dealt directly to a stat the character must take damage to that stat  unless it is mitigated somehow.

When a stat is damaged the current slot for that stat is reduced by points of damage taken.
\( current = current - damage \)
If this would push the slot into the negatives, or to 0 the character is dead. 

Raising a value is pretty much the same as taking damage, but in reverse.
The highest value is 8 and additional points are negated. 
\( current = current + raise \)

#+name: Character_Change_Stat
#+BEGIN_SRC python
  def change_stat(self, stat, value):
      """To raise the stat use a positive integer, 
      to lower the stat use a negative integer"""
      self.stat['current'] += value
      #Performs 0 check
      if self.stat['current'] < 0:
          self.stat['current'] = 0
      #Performs 8 check    
      if self.stat['current'] > 8:
          self.stat['current'] = 8
      #Change sucessful
      return None
#+END_SRC

Should a character take lethal damage before the haunt has started, the damage is negated and the stat is set to 1
This will be handled by the engine not the character object.

** Getting the stat value

** Miscellaneous Information 
Characters have some bits of miscellaneous information in addition to their core statistics.
This includes the name of the character, their age, birthday, hobbies, and other bits.
While it may seem a bit odd this information is used to determine player order, and in haunts.

** Character List
A list of the built in characters.
#+name: Character_List
#+BEGIN_SRC python
  Character_List = [
      Character(
          'Dillion "Zoom" Francis',
          "06/06",
          {'range':['dead',2,3,3,4,5,6,6,7],
           'starting': 3,
           'current': 3},
          {'range':['dead',4,4,4,5,6,7,7,8],
           'starting': 5,
           'current': 5},
          {'range':['dead',2,3,3,4,5,5,5,7],
           'starting': 3,
           'current': 3},
          {'range':['dead',1,2,3,4,5,5,5,7],
           'starting': 3,
           'current': 3}),
      Character(
          'Barry Bovine',
          "10/18",
          {'range':['dead',4,5,5,6,6,7,8,8],
           'starting': 3,
           'current': 3},
          {'range':['dead',2,2,2,3,4,5,5,6],
           'starting': 5,
           'current': 5},
          {'range':['dead',2,2,3,3,5,5,6,6],
           'starting': 3,
           'current': 3},
          {'range':['dead',2,2,3,4,5,5,6,7],
           'starting': 3,
           'current': 3}),
      Character(
          'Madame Zoltera',
          "12/10",
          {'range':['dead',2,3,3,4,5,5,5,6],
           'starting': 4,
           'current': 4},
          {'range':['dead',2,3,3,5,5,6,6,7],
           'starting': 3,
           'current': 3},
          {'range':['dead',1,3,4,4,4,5,6,6],
           'starting': 4,
           'current': 4},
          {'range':['dead',4,4,4,5,6,7,8,8],
           'starting': 3,
           'current': 3}),
      Character(
          'Vivian Martinez',
          "06/06",
          {'range':['dead',2,2,2,4,4,5,6,6],
           'starting': 3,
           'current': 3},
          {'range':['dead',3,4,4,4,4,6,7,8],
           'starting': 4,
           'current': 4},
          {'range':['dead',4,5,5,5,5,6,6,7],
           'starting': 4,
           'current': 4},
          {'range':['dead',4,4,4,5,6,7,8,8],
           'starting': 3,
           'current': 3}),




#+END_SRC

** Tests
#+BEGIN_SRC python :tangle tests/character_tests.py

  import unittest
#+END_SRC

* TODO Rooms
** Map
The map is a 3 dimensional space, with various points representing the rooms.
These points are always intigers, that can range from negative to positive.
Each point is represented by a 3 digit vector (x,y,z).
In normal operations Z should only ever range from -1 to 1. However I will not restrict this implicetly.
Movement across the map is in what is called Taxi-Cab geometry. You cannot move diagonally under normal operations.

Players can move any of the following directions:
Cardinal Directions:
 * North
 * South
 * East
 * West

Special Directions:
 * Up
 * Down
 * In
 * Out

East and West increase and decrease the x axis by 1
North and South increase and decrease the y axis by 1.

In and Out are special, and can be thought of teleporting the player or monster to whatever it is connected to.
In and Out only appear in a few cases, such as secret doors.
Up and Down could in theory increase and decrease the z axis. And in somecases it might. However the upperlanding and basement landing
are located at (0,0,1) and (0,0,-1) respectively. And rooms like the collapsed room, and the coal shute could be located anywhere on 
the map. However if the basement had not been explored yet, it could lead to situations where the players become trapped and never able to
return upstairs. To prevent this, up and down will also be treated like in and out. 

If at any point a floor becomes blocked off, the house is suppose to adjust itself, so that at least one door is free.
If there are no more rooms to discover but there are still open doors, those doors become disabled.


#+name: Map
#+BEGIN_SRC python :noweb yes  :tangle traitor/house.py 
  import itertools
  import random
  <<Room_Object>>
  <<map_discover>>
  MAP = {}

  MAP[(0,0,0)]= Room(
      "Entrance Hall",
      (True,True,False,True)
  )

  MAP[(0,1,0)] = Room(
      "Foyer",
      #Blank means all doors enabled
  )


  MAP[(0,2,0)] =  Room(
      "Grand Staircase",
      (False,False,True,False)
  )

  MAP[(0,0,1)] = Room(
      "Upper Landing",

  )

  MAP[(0,0,-1)] = Room(
      "Basement Landing",

  )


  for room in MAP:
      MAP[room].set_coordnate(room)
      MAP[room].set_edges()


  MAP[(0,0,0)].bi_connect("north", MAP[(0,1,0)])
  MAP[(0,1,0)].bi_connect("north", MAP[(0,2,0)])
  MAP[(0,2,0)].bi_connect("up", MAP[(0,0,1)])





#+END_SRC

#+RESULTS: Map

** Room Object
The room object is the representation of a room tile, the room object should be able to be easily represented by a table.
A room contains a few bits of information:
 1. The Room's Name:
  This is a string of arbitrary length and characters.
 2. The Room's Shape:
  Rooms in traitor are square tiles with a number of doors in them. The shape is represented with a tuple indicating whether or not
  that particular door is enabled.
  #+BEGIN_EXAMPLE
    (True,True,True,True)
  #+END_EXAMPLE
  If no shape is given, the room assumes that all doors have been enabled. And therefore are valid directions.
 3. The Room's Floor:
  Not all rooms are allowed on all floors. If no value is given, the room assumes that it is allowed on any floor.
 4. What Happens There:
  In traitor, there are a number of items, events, and omens, that are found through out the house.
  Some rooms are harder to move through, and some rooms will either hurt you, or heal you.
 
 #+name: Room_Object
 #+BEGIN_SRC python
   class Room(object):


       cardinal_directions = ('north','east','south','west')
       special_directions = ('up','down','in','out')
       edge_table = (
           ('north','south'),
           ('south','north'),
           ('east','west'),
           ('west','east'),
           ('up','down'),
           ('down','up'),
           ('in','out'),
           ('out','in'))





       def __init__(self,
                    name,
                    shape=(True, True, True, True),
                    allowed_floors=(-1,0,1)):
           self.name = name
           self.shape = shape
           self.allowed_floors = allowed_floors

           self.edges = []
           for edge in shape:
               self.edges.append(
                   {"direction": None,
                    "connection": None,
                    "enabled": edge
                    })

       def set_edges(self, rotation=0):
           """
           Rotation is an integer between 0-3.
           Anything higher is redundant and any < 0 will cause trouble.
           """
           if rotation < 0:
               raise ValueError

           direction_wheel = itertools.cycle(self.cardinal_directions)

           for n in range(int(rotation)):
               direction_wheel.__next__()
               continue

           for edge in self.edges:
               edge['direction'] = direction_wheel.__next__()
               continue

           return None

       def set_coordnate(self,coordnate):
           self.x,self.y,self.z = coordnate
           return None

       def get_coordnate(self):
           return (self.x,self.y,self.z)

       <<Connect_Rooms>>
       <<Connection_Test_Methods>>
       <<Move_Room>>



 #+END_SRC

** Connecting Rooms
#+name: Connect_Rooms
#+BEGIN_SRC python 

  def connect(self, direction, room):

      if direction in self.special_directions:
          self.edges.append(
              {"direction": direction,
               "connection": room.get_coordnate()
              }
              )
          return None
      for edge in self.edges:
          if direction in edge['direction']:
              edge['direction'] = direction
              edge['connection'] = room.get_coordnate()
              return None
          else:
              pass



  def bi_connect(self, direction, room):

      opposite_direction = None
      for d in self.edge_table:
          if d[0] == direction:
              opposite_direction = d[1]
              break
          else:
              continue
      if opposite_direction == None:
          return "Error: Missing Opposite Edge!"

      self.connect(direction, room)
      room.connect(opposite_direction, self)



#+END_SRC

** Check Connection
#+name: Connection_Test_Methods
#+BEGIN_SRC python
  def is_connected_at(self, direction):
      for edge in self.edges:
          if edge["direction"] == direction:
              return True

      return False

  def is_connected_to(self,room):
      for edge in self.edges:
          if edge["connection"] == room:
              return True
      return False

  def is_connected_to_at(self,direction,room):
      for edge in self.edges:
          con_1 = edge["direction"] == direction
          con_2 = edge["connection"] == room
          if con_1 and con_2:
              return True

      return False
#+END_SRC

** Moving Between Rooms
Room objects have a move method, this takes a direction from their edges table and returns the coordnates.
The idea is so that each character, monster, ect has a "position" that is the room's coordnates.
In the event that the room hasn't been discovered, it sends up an assertion error that signals to the engine to discover a room.

#+name: Move_Room
#+BEGIN_SRC python 
  def move(self, direction):

      for edge in self.edges:
          if edge["direction"] == direction:
              assert edge["enabled"] != False
              return edge["connection"]




#+END_SRC
** TODO Barrier Rooms
Barrier rooms are a subtype of room, you can enter from one side but inorder to cross it you mut pass some sort of challenge.
For the most part these are simply a roll, however if you fail the challenge you stop moving for the turn.
The traitor and monsters are immune to these challenges unless noted.
** TODO Ending Conditions
If you end your turn in these rooms something happeneds. This can be negative or positive.
However negative effects tend to happen anytime you end your turn in that room; whereas positive tend to only
happen once per player per game.
** TODO Special Rooms
These rooms all have something special about them by default that is difficult to catagories, or would lead to unnessisarly
overly complicated pieces. Instead these rooms all get clumped into the catagory of "special".
*** TODO Mystic Elevator
*** TODO Coal Chute
*** TODO Gallery
*** TODO Vault
*** TODO Collapsed Room

** Discovering Rooms
Should a player move into a room that hasn't been discovered yet, that player uncovers a new room.
This selection is done at random from the room list, certain rooms can only be placed on certain floors.
If the newly discoved room has an event in it, the player must stop moving and activate the event!

#+name: map_discover
#+BEGIN_SRC python

  def spawn_room(coordnate, room):
      MAP[coordnate] = room
      return None




#+END_SRC

** Python Room List
 #+name: List_of_Rooms
 #+BEGIN_SRC python
   List_of_Rooms = [
       Room(
           "Wine Cellar",
           (True,False,True,False),
           (-1),
           #Item
           ),
       Room(
           "Junk Room",
           (True,True,True,True),
           (-1,0,1),
           #Omen,
           #Exit Condition
           ),
       Room(
           "Organ Room",
           (False,False,True,True),
           (-1,0,1),
           #Event
           ),
       Room(
           "Storeroom",
           (True,False,False,False),
           (-1,1)
           #Item
           ),
       Room(
           "Creaky Hallway",
           (True,True,True,True),
           (-1,0,1),
           #None
           ),
       Room(
           "Dusty Hallway",
           (True,True,True,True),
           (-1,0,1),
           #None
           ),
       Room(
           "Furnace Room",
           (True,False,True,True),
           (-1),
           #Omen,
           #Ending Condition
           ),
       Room(
           "Stairs from Basement",
           (False,False,True,False),
           (-1),
           #None,
           #Biconnects to Foyer
           ),
       Room(
           "Operating Laboratory",
           (False,True,True,False),
           (-1,1),
           #Event
           ),
       Room(
           "Pentagram Chamber",
           (False,True,False,False),
           (-1),
           #Omen,
           #Ending Condition
           ),
       Room(
           "Attic",
           (False,False,True,False),
           (1),
           #Event,
           #Exit Condition
           ),
       Room(
           "Chapel"
           (True,False,False,False),
           (0,1),
           #Event,
           #Ending Condition
           ),
       Room(
           "Research Laboratory",
           (True,False,True,False),
           (-1,1),
           #Event
           ),
       Room(
           "Mystic Elevator",
           (True,False,False,False),
           (-1,0,1),
           #None,
           #Mystic Elevator
           ),
       Room(
           "Vault",
           (True,False,False,False),
           (-1,1),
           #Event,
           #Vault
           ),
       Room(
           "Gardens",
           (True,False,True,False),
           (0),
           #Event,
           ),
       Room(
           "Graveyard",
           (False,False,True,False),
           (0),
           #Event,
           #Exiting Condition
           ),
       Room(
           "Patio",
           (True,False,True,True),
           (0),
           #Event
           ),
       Room(
           "Servants' Quarters",
           (True,True,True,True),
           (-1,1),
           #Omen
           ),
       Room(
           "Catacombs",
           (True,False,True,False),
           (-1),
           #Omen
           #Moving Condition
           ),
       Room(
           "Ballroom",
           (True,True,True,True),
           (0),
           #Event
           ),
       Room(
           "Gymnasium",
           (False,True,True,False),
           (-1,1),
           #Omen,
           #Ending Condition
           ),
       Room(
           "Tower",
           (False,True,False,True),
           (1),
           #Event,
           #Moving Condition
           ),
       Room(
           "Larder",
           (True,False,True,False),
           (-1),
           #Item
           #Ending Condition
           ),
       Room(
           "Bloody Room",
           (True,True,True,True),
           (0,1),
           #Item
           ),
       Room(
           "Dining Room",
           (True,True,False,False),
           (0),
           #Omen
           )
       Room(
           "Master Bedroom",
           (True,False,False,True),
           (1),
           #Omen
           ),
       Room(
           "Conservatory",
           (True,False,False,False),
           (0,1),
           #Event
           ),
       Room(
           "Collapsed Room",
           (True,True,True,True),
           (0,1),
           #None,
           #Collapsed Room
           ),
       Room(
           "Bedroom",
           (False,True,False,True),
           (1),
           #Event
           ),
       Room(
           "Coal Chute",
           (True,False,False,False),
           (0),
           #None,
           #Coal Chute
           ),
       Room(
           "Game Room",
           (True,True,True,False),
           (-1,0,1),
           #Event
           ),
       Room(
           "Library",
           (False,False,True,True),
           (0,1),
           #Event,
           #Ending Condition
           ),
       Room(
           "Charred Room",
           (True,True,True,True),
           (0,1),
           #Omen
           ),
       Room(
           "Abandoned Room",
           (True,True,True,True),
           (-1,0),
           #Omen
           ),
       Room(
           "Balcony",
           (True,False,True,False),
           (1),
           #Omen,
           ),
       Room(
           "Statuary Corridor",
           (True,False,True,False),
           (-1,0,1),
           #Event
           ),
       Room(
           "Underground Lake",
           (True,True,False,False),
           (-1),
           #Event
           ),
       Room(
           "Kitchen",
           (True,True,False,False),
           (-1,0),
           #Omen
           ),
       Room(
           "Chasm",
           (False,True,False,True),
           (-1),
           #None
           #Moving Condition
           ),
       Room(
           "Crypt",
           (True,False,False,False),
           (-1),
           #Event
           #Ending Condition
           ),
       Room(
           "Gallery",
           (True,False,True,False),
           (1),
           #Omen,
           #Gallery
           )
       ]
 #+END_SRC

** Tests
#+name: Map_Tests
#+BEGIN_SRC python :tangle tests/map_tests.py 
  import unittest
  import sys
  from traitor import house

  class MapUnitTests(unittest.TestCase):

      def setUp(self):
          self.MAP = house.MAP

      def test_if_rooms_exist(self):
          list_of_rooms = [[r, self.MAP[r]] for r in self.MAP]
          self.assertNotEqual(len(list_of_rooms),0)

      def test_if_rooms_connected(self):
          #Check if connections can be made

          self.assertTrue(
          self.MAP[(0,0,0)].is_connected_at('north'),
          self.MAP[(0,0,0)].edges
          )
          self.assertTrue(
          self.MAP[(0,1,0)].is_connected_at('north')
              )
          self.assertTrue(
          self.MAP[(0,2,0)].is_connected_at('up')
              )

          #Check reverse connections.
          self.assertTrue(
          self.MAP[(0,1,0)].is_connected_at('south')
              )
          self.assertTrue(
          self.MAP[(0,2,0)].is_connected_at('south')
              )
          self.assertTrue(
          self.MAP[(0,0,1)].is_connected_at('down')
              )


      def test_can_move_between_rooms(self):
          pos = self.MAP[(0,0,0)]

          pos = self.MAP[pos.move('north')]

          self.assertEqual(pos,self.MAP[(0,1,0)],
                           "Position did not move!")
          pos = self.MAP[pos.move('south')]

          self.assertEqual(pos,self.MAP[(0,0,0)],
                           "Position failed in reverse")

      def test_cannot_move_invalid_direction(self):

          pos = self.MAP[(0,0,0)]
          try:
              pos = self.MAP[pos.move('up')]
          except KeyError:
              self.assertEqual(pos,self.MAP[(0,0,0)])


      def test_does_not_move_if_room_is_undiscovered(self):

          pos = self.MAP[(0,0,0)]
          try:
              pos.move("east")
          except AssertionError:
              self.assertEqual(pos,self.MAP[(0,0,0)])


      def test_can_spawn_new_rooms(self):
          discovered_room = house.Room(
              "Test Room",

          )


          pos = self.MAP[(0,0,0)]
          house.spawn_room(
              (1,0,0),
              discovered_room
          )
          self.MAP[(1,0,0)].set_coordnate((1,0,0))
          self.MAP[(1,0,0)].set_edges()

          pos.bi_connect('east',self.MAP[(1,0,0)])

          pos = self.MAP[pos.move('east')]

          self.assertEqual(pos,self.MAP[(1,0,0)],
                           "Wrong room?!? {0}".format(pos.name)
          )

          #From Room experiment

      def test_rooms_have_no_direction_by_default(self):
          test_room = house.Room(
              "test_room"
          )
          for edge in test_room.edges:
              self.assertEqual(edge['direction'], None)

      def test_rooms_default_rotation(self):
          test_room = house.Room(
              "test_room")
          test_room.set_edges()
          edges = test_room.edges
          directions = test_room.cardinal_directions
          zipped = zip(edges, directions)
          for edge, direction in zipped:
              self.assertEqual(edge["direction"], direction)

      def test_rooms_rotation(self):
          test_room = house.Room(
              "test_room")
          test_room.set_edges(1)
          edges = test_room.edges
          self.assertEqual(
              edges[0]['direction'], 'east')
          self.assertEqual(
              edges[1]['direction'], 'south')
          self.assertEqual(
              edges[2]['direction'], 'west')
          self.assertEqual(
              edges[3]['direction'], 'north')







#+END_SRC

* TODO Items
* TODO Events
* TODO Omens
* TODO Haunts
** Haunt Table
:PROPERTIES:
:COLUMNS: %ITEM %OMEN %ROOM
:END: 
* TODO Engine
We start putting things together here in the engine
#+BEGIN_SRC python :tangle traitor/main.py :noweb yes  :shebang #!/usr/bin/env python3
  import sys
  import house
  class player(object):

      def __init__(self):

          self.pos = house.MAP[(0,0,0)]
          return None

      def repl(self):
          print("Traitor pre-alpha demo")
          print("Made by Daniel A Smith")
          prompt = '==> '

          while True:
              command = input(prompt)
              command_parsed = command.split()
              if len(command_parsed) == 0:
                  pass
              elif command_parsed[0] == 'go':
                  try:
                      self.go(command_parsed[1])
                  except IndexError:
                      d = input("Which direction do you want to go?: ")
                      self.go(d)
                  except:
                      print("Something went wrong")
              elif command_parsed[0] == 'look':
                  self.look()
              elif command_parsed[0] == 'quit':
                  self.quit()
              else:
                  print("Invaild command, sorry")


      def go(self,direction):
          try:
              self.pos = self.house.MAP[self.pos.move(direction)]
              print(self.pos.name, self.pos.get_coordnate())
              return None
          except AssertionError:
              x,y,z = self.pos.get_coordnate()

              if direction == "north":
                  y += 1
              if direction == "south":
                  y -= 1
              if direction == "east":
                  x += 1
              if direction == "west":
                  x -= 1

              try:
                  self.pos.bi_connect(direction, self.house.MAP[(x,y,z)])
                  self.pos = self.house.MAP[self.pos.move(direction)]
                  print(self.pos.name, self.pos.get_coordnate())
              except KeyError:

                  self.house.spawn_room((x,y,z),
					house.List_of_Rooms.pop())
                  self.house.MAP[(x,y,z)].set_coordnate((x,y,z))
                  self.house.MAP[(x,y,z)].set_edges()
                  self.pos.bi_connect(direction, self.house.MAP[(x,y,z)])
                  self.pos = self.house.MAP[self.pos.move(direction)]
                  print(self.pos.name, self.pos.get_coordnate())
                  return None
          except KeyError:
              print("Invaild direction!")
              print(self.pos.name, self.pos.get_coordnate())
              return None

      def quit(self):
          sys.exit()

      def look(self):
          print("You are in the {}".format(self.pos.name))
          print("You can go: ")
          for edge in self.pos.edges:
              print(edge['direction'])
          return None


  if __name__ == '__main__':
      me = player(house)
      me.repl()
#+END_SRC
