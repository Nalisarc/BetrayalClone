#+Title: Traitor
#+author: Daniel Alexander Smith
#+email: nalisarc@gmail.com
* TODO Readme
* TODO License
* TODO Characters
** Character Object
#+name: Character_Object
#+BEGIN_SRC python :noweb yes 
  class Character(object):

      def __init__(self):

          self.name = name
          self.birthday = birthday

          #Stat lists

          self.might = might
          self.speed = speed
          self.knowledge = knowledge
          self.sanity = sanity

          #Inventory
          self.inventory = []

      <<Character_Change_Stat>>
    
#+END_SRC
** Statistics
Stats are represented as dictionaries containing the following bits of info:
 * Value tuple
 * Starting Slot
 * Current Slot

Each stat contains a list of 9 possible vaules. The 0 slot of each stat is always "dead".
The remaining stats represent the number of dice that are roled for that type of roll.
The speed stat is also used to tell how many spaces a character can move per turn.
#+name: Statistic_Example
#+BEGIN_SRC python :exports code 
  might = {
      'range': ('dead',1,2,3,4,5,5,6,6)
      'starting': 3
      'current': 3
      }
#+END_SRC
There might be some confusion about what the starting and current values mean.
These reference the range tuple slot, not the actual value itself. 

** Changing Stats
Sometimes in the game your characters will take damage.
Characters have four stats, these are broken up into two different catagories:
1. Mental
   * Knowledge
   * Sanity
2. Physical
   * Might
   * Speed

If a character takes damage to a category they have the ability to chose which stat takes the damage, 
and in cases of multiple points they can divide the points up however they chose so long all the points of damage are taken.
However if damage is dealt directly to a stat the character must take damage to that stat  unless it is mitigated somehow.

When a stat is damaged the current slot for that stat is reduced by points of damage taken.
\( current = current - damage \)
If this would push the slot into the negatives, or to 0 the character is dead. 

Raising a value is pretty much the same as taking damage, but in reverse.
The highest value is 8 and additional points are negated. 
\( current = current + raise \)

#+name: Character_Change_Stat
#+BEGIN_SRC python
  def change_stat(self, stat, value):
      """To raise the stat use a positive integer, 
      to lower the stat use a negative integer"""
      self.stat['current'] += value
      #Performs 0 check
      if self.stat['current'] < 0:
          self.stat['current'] = 0
      #Performs 8 check    
      if self.stat['current'] > 8:
          self.stat['current'] = 8
      #Change sucessful
      return None
#+END_SRC

Should a character take lethal damage before the haunt has started, the damage is negated and the stat is set to 1
This will be handled by the engine not the character object.



** Miscellaneous Information 
Characters have some bits of miscellaneous information in addition to their core statistics.
This includes the name of the character, their age, birthday, hobbies, and other bits.
While it may seem a bit odd this information is used to determine player order, and in haunts.

* TODO Rooms
The house in Traitor is never the same.
The house is generated by a series of rooms that are randomly arranged.
There are some constants about the house however, the house is always three floors.
You will always start on the first floor.
At the end of the entrance hall is a stair case to the second floor.
The staircase to the basement is hidden so you'll have to find it, once you do it is always connected to the end of the hall.

** TODO Map
The map contains where the rooms are. 
The entrance hall is always located at (0,0,0) and goes til (0,3,0).

Players can move any of the following directions:
Cardinal Directions:
 * North
 * South
 * East
 * West
Special Directions:
 * Up
 * Down
 * In
 * Out

North and South moves upon the Y axis, East and West on the X axis.
Up and Down moves upon the Z axis.
Some rooms have special directions that connect to, these go to a specific cordnate.

#+name: Map
#+BEGIN_SRC python :noweb yes :tangle tratior/housemap.py 
  <<Room_Object>>

  def setup():
      MAP = {}

      MAP['000']= Room(
          "Entrance Hall",
          '000',
          ("north","east","west"))

      MAP['001'] = Room(
          "Foyer",
          '001',
          ("north","south","east","west"))


      MAP['002'] =  Room(
          "Grand Staircase",
          '002',
          ("south","east","west"))

      MAP['100'] = Room(
          "Upper Landing",
          '100',
          ("north","south","east","west"))

      MAP['-100'] = Room(
          "Basement Landing",
          '-100',
          ("north","south","east","west"))


      MAP['000'].connect("north", MAP['001'])
      MAP['001'].connect("north", MAP['002'])
      MAP['002'].connect("up", MAP['100'])

      return MAP



#+END_SRC

#+RESULTS: Map

** TODO Room Object
#+name: Room_Object
#+BEGIN_SRC python
  class Room(object):

      def __init__(self,
                   name,
                   coordnate,
                   allowed_edges):

          self.name = name
          self.coordnate = coordnate
          self.edges = {}
          for edge in allowed_edges:
              self.edges[edge] = None
          return None

      <<Connect_Rooms>>
      <<Connection_Test_Methods>>





#+END_SRC
Room objects have a name, a dictonary telling which direction connects to which other room.
Some rooms have something happen in them either you find a item, an omen, or an event. 
This is stored in the card value.
** Connecting Rooms
The connect function binds two rooms together at the opposet edge.

#+name: edge_table
| Input | Opposite |
|-------+----------|
| north | south    |
| south | north    |
| east  | west     |
| west  | east     |
| in    | out      |
| out   | in       |
| up    | down     |
| down  | up       |

#+name: Connect_Rooms
#+BEGIN_SRC python :var edges=edge_table() 
  def connect(self, direction, room):
      edge_table = [
          ["north","south"],
          ["south","north"],
          ["east","west"],
          ["west","east"],
          ["in","out"],
          ["out","in"],
          ["up","down"],
          ["down","up"]
      ]
      opposite_direction = None
      for d in edge_table:
          if d[0] == direction:
              opposite_direction = d[1]
              break
          else:
              continue
      if opposite_direction == None:
          return "Error: Missing Opposite Edge!"
      self.edges[direction] = room
      room.edges[opposite_direction] = self
      return None


#+END_SRC

** Check Connection
#+name: Connection_Test_Methods
#+BEGIN_SRC python
  def is_connected_at(self, direction):
      if self.edges[direction] != None:
          return True
      else:
          return False

  def is_connected_to(self,room):
      if room in self.edges.values():
          return True
      else:
          return False

  def is_connected_to_at(self, room, direction):
      condition1 = self.is_connected_at(direction)
      condition2 = self.is_connected_to(room)
      if condition1 and condition2:
          return True
      else:
          return False
    
#+END_SRC

** Tests
#+name: Map_Tests
#+BEGIN_SRC python :tangle tests/map_tests.py 
  import unittest
  import sys
  from traitor import housemap

  class MapUnitTests(unittest.TestCase):

      def setUp(self):
          self.MAP = housemap.setup()
        

      def test_if_rooms_exist(self):
          list_of_rooms = [[r.key(),r.value()] for r in self.MAP]
          self.assertNotEqual(len(list_of_rooms),0)

      def test_if_rooms_connected(self):

          self.assertTrue(
          self.MAP['000'].is_connected_at('north')
              )
          self.assertTrue(
          self.MAP['001'].is_connected_at('north')
              )
          self.assertTrue(
          self.MAP['002'].is_connected_at('up')
              )
        
        


  if __name__ == '__main__':
      unittest.main()
      sys.exit()


#+END_SRC

* TODO Cards
** TODO Items
** TODO Events
** TODO Omens
* TODO Haunts
