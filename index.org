#+Title: Traitor
#+author: Daniel Alexander Smith
#+email: nalisarc@gmail.com
* TODO Readme
* TODO License
* TODO Characters
** Character Object
#+name: Character_Object
#+BEGIN_SRC python :noweb yes 
  class Character(object):

      def __init__(self,
                   name,
                   birthday,
                   might,
                   speed,
                   knowledge,
                   sanity):

          self.name = name
          self.birthday = birthday

          #Stat lists

          self.might = might
          self.speed = speed
          self.knowledge = knowledge
          self.sanity = sanity

          #Inventory
          self.inventory = []

      <<Character_Change_Stat>>

#+END_SRC
** Statistics
Stats are represented as dictionaries containing the following bits of info:
 * Value tuple
 * Starting Slot
 * Current Slot

Each stat contains a list of 9 possible vaules. The 0 slot of each stat is always "dead".
The remaining stats represent the number of dice that are roled for that type of roll.
The speed stat is also used to tell how many spaces a character can move per turn.
#+name: Statistic_Example
#+BEGIN_SRC python :exports code 
  might = {
      'range': ('dead',1,2,3,4,5,5,6,6)
      'starting': 3
      'current': 3
      }
#+END_SRC
There might be some confusion about what the starting and current values mean.
These reference the range tuple slot, not the actual value itself. 

** Changing Stats
Sometimes in the game your characters will take damage.
Characters have four stats, these are broken up into two different catagories:
1. Mental
   * Knowledge
   * Sanity
2. Physical
   * Might
   * Speed

If a character takes damage to a category they have the ability to chose which stat takes the damage, 
and in cases of multiple points they can divide the points up however they chose so long all the points of damage are taken.
However if damage is dealt directly to a stat the character must take damage to that stat  unless it is mitigated somehow.

When a stat is damaged the current slot for that stat is reduced by points of damage taken.
\( current = current - damage \)
If this would push the slot into the negatives, or to 0 the character is dead. 

Raising a value is pretty much the same as taking damage, but in reverse.
The highest value is 8 and additional points are negated. 
\( current = current + raise \)

#+name: Character_Change_Stat
#+BEGIN_SRC python
  def change_stat(self, stat, value):
      """To raise the stat use a positive integer, 
      to lower the stat use a negative integer"""
      self.stat['current'] += value
      #Performs 0 check
      if self.stat['current'] < 0:
          self.stat['current'] = 0
      #Performs 8 check    
      if self.stat['current'] > 8:
          self.stat['current'] = 8
      #Change sucessful
      return None
#+END_SRC

Should a character take lethal damage before the haunt has started, the damage is negated and the stat is set to 1
This will be handled by the engine not the character object.


** Miscellaneous Information 
Characters have some bits of miscellaneous information in addition to their core statistics.
This includes the name of the character, their age, birthday, hobbies, and other bits.
While it may seem a bit odd this information is used to determine player order, and in haunts.

** Character List
A list of the built in characters.
#+name: Character_List
#+BEGIN_SRC python
  Character_List = [
      Character(
          'Dillion "Zoom" Francis',
          "06/06",
          {'range':['dead',2,3,3,4,5,6,6,7],
           'starting': 3,
           'current': 3},
          {'range':['dead',4,4,4,5,6,7,7,8],
           'starting': 5,
           'current': 5},
          {'range':['dead',2,3,3,4,5,5,5,7],
           'starting': 3,
           'current': 3},
          {'range':['dead',1,2,3,4,5,5,5,7],
           'starting': 3,
           'current': 3}),
      Character(
          'Barry Bovine',
          "10/18",
          {'range':['dead',4,5,5,6,6,7,8,8],
           'starting': 3,
           'current': 3},
          {'range':['dead',2,2,2,3,4,5,5,6],
           'starting': 5,
           'current': 5},
          {'range':['dead',2,2,3,3,5,5,6,6],
           'starting': 3,
           'current': 3},
          {'range':['dead',2,2,3,4,5,5,6,7],
           'starting': 3,
           'current': 3}),
      Character(
          'Madame Zoltera',
          "12/10",
          {'range':['dead',2,3,3,4,5,5,5,6],
           'starting': 4,
           'current': 4},
          {'range':['dead',2,3,3,5,5,6,6,7],
           'starting': 3,
           'current': 3},
          {'range':['dead',1,3,4,4,4,5,6,6],
           'starting': 4,
           'current': 4},
          {'range':['dead',4,4,4,5,6,7,8,8],
           'starting': 3,
           'current': 3}),
      Character(
          'Vivian Martinez',
          "06/06",
          {'range':['dead',2,2,2,4,4,5,6,6],
           'starting': 3,
           'current': 3},
          {'range':['dead',3,4,4,4,4,6,7,8],
           'starting': 4,
           'current': 4},
          {'range':['dead',4,5,5,5,5,6,6,7],
           'starting': 4,
           'current': 4},
          {'range':['dead',4,4,4,5,6,7,8,8],
           'starting': 3,
           'current': 3}),




#+END_SRC

* TODO Rooms
The house in Traitor is never the same.
The house is generated by a series of rooms that are randomly arranged.
There are some constants about the house however, the house is always three floors.
You will always start on the first floor.
At the end of the entrance hall is a stair case to the second floor.
The staircase to the basement is hidden so you'll have to find it, once you do it is always connected to the end of the hall.

** TODO Map
The map contains where the rooms are. 
The entrance hall is always located at (0,0,0) and goes til (0,2,0).

Players can move any of the following directions:
Cardinal Directions:
 * North
 * South
 * East
 * West
Special Directions:
 * Up
 * Down
 * In
 * Out

North and South moves upon the Y axis, East and West on the X axis.
Up and Down moves upon the Z axis.
Some rooms have special directions that connect to, these go to a specific cordnate.

#+name: Map
#+BEGIN_SRC python :noweb yes  :tangle traitor/housemap.py 
  <<Room_Object>>
  <<List_of_Rooms>>
  class Map(object):
      def __init__(self):
          MAP = {}

          MAP[(0,0,0)]= Room(
              "Entrance Hall",
              3
          )

          MAP[(0,1,0)] = Room(
              "Foyer",
              4
          )


          MAP[(0,2,0)] =  Room(
              "Grand Staircase",
              4
          )

          MAP[(0,0,1)] = Room(
              "Upper Landing",
              4
          )

          MAP[(0,0,-1)] = Room(
              "Basement Landing",
              4
          )


          for room in MAP:
              MAP[room].set_coordnate(room)
              MAP[room].set_edges()


          MAP[(0,0,0)].bi_connect("north", MAP[(0,1,0)])
          MAP[(0,1,0)].bi_connect("north", MAP[(0,2,0)])
          MAP[(0,2,0)].bi_connect("up", MAP[(0,0,1)])




          self.MAP = MAP

      <<map_discover>>  




#+END_SRC

#+RESULTS: Map

** Room Object
 #+name: Room_Object
 #+BEGIN_SRC python
   class Room(object):


       cardinal_directions = ['north','south','east','west']
       special_directions = ['up','down','in','out']
       edge_table = [
           ['north','south'],
           ['south','north'],
           ['east','west'],
           ['west','east'],
           ['up','down'],
           ['down','up'],
           ['in','out'],
           ['out','in']]



       def __init__(self,
                    name,
                    number_of_doors):

           self.name = name
           self.edges = []

           for d in range(number_of_doors):
               self.edges.append({
                   "direction": None,
                   "connection": None
               })


       def set_coordnate(self,coordnate):
           self.x,self.y,self.z = coordnate
           return None

       def get_coordnate(self):
           return (self.x,self.y,self.z)

       def set_edges(self):
           for r, d in zip(self.edges, self.cardinal_directions):
               r['direction'] = d
           return None
        

       <<Connect_Rooms>>
       <<Connection_Test_Methods>>
       <<Move_Room>>



 #+END_SRC
 Room objects have a name, a dictonary telling which direction connects to which other room.
 Some rooms have something happen in them either you find a item, an omen, or an event. 
 This is stored in the card value.
** Connecting Rooms
The connect function binds two rooms together at the opposet edge.

#+name: edge_table
| Input | Opposite |
|-------+----------|
| north | south    |
| south | north    |
| east  | west     |
| west  | east     |
| in    | out      |
| out   | in       |
| up    | down     |
| down  | up       |



#+name: Connect_Rooms
#+BEGIN_SRC python 

  def connect(self, direction, room):

      if direction in self.special_directions:
          self.edges.append(
              {"direction": direction,
               "connection": room.get_coordnate()
              }
              )
          return None
    
      for edge in self.edges:
          if edge["direction"] == direction:
              edge["connection"] = room.get_coordnate()
              return None
          else:
              pass

      for edge in self.edges:
          if edge["direction"] == None:
              edge["direction"] = direction
              edge["connection"] = room.get_coordnate()
              return None
          else:
              pass

      return None

  def bi_connect(self, direction, room):

      opposite_direction = None
      for d in self.edge_table:
          if d[0] == direction:
              opposite_direction = d[1]
              break
          else:
              continue
      if opposite_direction == None:
          return "Error: Missing Opposite Edge!"

      self.connect(direction, room)
      room.connect(opposite_direction, self)




#+END_SRC

** Check Connection
#+name: Connection_Test_Methods
#+BEGIN_SRC python
  def is_connected_at(self, direction):
      for edge in self.edges:
          if edge["direction"] == direction:
              return True

      return False

  def is_connected_to(self,room):
      for edge in self.edges:
          if edge["connection"] == room:
              return True
      return False

  def is_connected_to_at(self,direction,room):
      for edge in self.edges:
          con_1 = edge["direction"] == direction
          con_2 = edge["connection"] == room
          if con_1 and con_2:
              return True

      return False
#+END_SRC

** Moving Between Rooms
Room objects have a move method, this takes a direction from their edges table and returns the coordnates.
The idea is so that each character, monster, ect has a "position" that is the room's coordnates.
In the event that the room hasn't been discovered, it sends up an assertion error that signals to the engine to discover a room.

#+name: Move_Room
#+BEGIN_SRC python 
  def move(self, direction):

      for edge in self.edges:
          if edge["direction"] == direction:
              assert edge["connection"] != None
              return edge["connection"]
      raise KeyError



#+END_SRC

** Discovering Rooms
Should a player move into a room that hasn't been discovered yet, that player uncovers a new room.
This selection is done at random from the room list, certain rooms can only be placed on certain floors.
If the newly discoved room has an event in it, the player must stop moving and activate the event!

#+name: map_discover
#+BEGIN_SRC python

  def spawn_room(self, coordnate, room):
      self.MAP[coordnate] = room
      return None




#+END_SRC

** List of Rooms
#+name: List_of_Rooms
#+BEGIN_SRC python
  List_of_Rooms = [
      Room("Chasm",2),
      Room("Crypt",1),
      Room("Gallery",2),
      Room("Pentagram Chamber",1),
      Room("Attic", 1),
      Room("Chapel", 1),
      Room("Collapsed Room",4),
      Room("Balcony",2),
      Room("Stairs from Basement",1),
      Room("Graveyard",1),
      Room("Gardens",2),
      Room("Kitchen",2),
      Room("Vault",1),
      Room("Mystic Elevator",1),
      Room("Statuary Corridor",2),
      Room("Research Laboratory",2),
      Room("Underground Lake",2),
      Room("Furnace Room",3),
      Room("Catacombs",2),
      Room("Ballroom",4),
      Room("Game Room",3),
      Room("Library",2),
      Room("Charred Room", 4),
      Room("Abandoned Room", 4),
      Room("Dining Room", 2),
      Room("Conservatory",1),
      Room("Master Bedroom",2),
      Room("Bloody Room",4),
      Room("Tower",2),
      Room("Gymnasium", 2),
      Room("Operating Laboritory", 2),
      Room("Coal Chute",1),
      Room("Bedroom", 2),
      Room("Balcony",2),
      Room("Junk Room",2),
      Room("Creaky Hallway",4)
      ]

#+END_SRC

** Tests
#+name: Map_Tests
#+BEGIN_SRC python :tangle tests/map_tests.py 
  import unittest
  import sys
  from traitor import housemap

  class MapUnitTests(unittest.TestCase):

      def setUp(self):

          self.house = housemap.Map()
          self.MAP = self.house.MAP

      def test_if_rooms_exist(self):
          list_of_rooms = [[r, self.MAP[r]] for r in self.MAP]
          self.assertNotEqual(len(list_of_rooms),0)

      def test_if_rooms_connected(self):
          #Check if connections can be made

          self.assertTrue(
          self.MAP[(0,0,0)].is_connected_at('north')
              )
          self.assertTrue(
          self.MAP[(0,1,0)].is_connected_at('north')
              )
          self.assertTrue(
          self.MAP[(0,2,0)].is_connected_at('up')
              )

          #Check reverse connections.
          self.assertTrue(
          self.MAP[(0,1,0)].is_connected_at('south')
              )
          self.assertTrue(
          self.MAP[(0,2,0)].is_connected_at('south')
              )
          self.assertTrue(
          self.MAP[(0,0,1)].is_connected_at('down')
              )

      def test_can_move_between_rooms(self):
          pos = self.MAP[(0,0,0)]

          pos = self.MAP[pos.move('north')]

          self.assertEqual(pos,self.MAP[(0,1,0)],
                           "Position did not move!")
          pos = self.MAP[pos.move('south')]

          self.assertEqual(pos,self.MAP[(0,0,0)],
                           "Position failed in reverse")

      def test_cannot_move_invalid_direction(self):

          pos = self.MAP[(0,0,0)]
          try:
              pos = self.MAP[pos.move('up')]
          except KeyError:
              self.assertEqual(pos,self.MAP[(0,0,0)])


      def test_does_not_move_if_room_is_undiscovered(self):

          pos = self.MAP[(0,0,0)]
          try:
              pos.move("east")
          except AssertionError:
              self.assertEqual(pos,self.MAP[(0,0,0)])


      def test_can_spawn_new_rooms(self):
          discovered_room = housemap.Room(
              "Test Room",
              3
          )

          pos = self.MAP[(0,0,0)]
          self.house.spawn_room(
              (1,0,0),
              discovered_room
          )
          self.MAP[(1,0,0)].set_coordnate((1,0,0))

          pos.bi_connect('east',self.MAP[(1,0,0)])

          pos = self.MAP[pos.move('east')]

          self.assertEqual(pos,self.MAP[(1,0,0)],
                           "Wrong room?!? {0}".format(pos.name)
          )









#+END_SRC

* TODO Cards
** TODO Items
** TODO Events
** TODO Omens

* TODO Haunts
* Engine
We start putting things together here in the engine
#+BEGIN_SRC python :tangle traitor/main.py :noweb yes  :shebang #!/usr/bin/env python3
  import sys
  import housemap
  <<Character_Object>>
  house = housemap.Map()

  class player(object):

      def __init__(self, house):

          self.house = house
          self.pos = self.house.MAP[(0,0,0)]
          return None

      def repl(self):
          prompt = '==>'
          while True:

              i = input(prompt)
              if i == "go":
                  direction = input("Which direction: ")
                  self.go(direction)
              elif i == "quit":
                  self.quit()

              elif i == "":
                  pass
              else:
                  print("Im sorry Dave, I'm afraid I can't do that")



      def go(self,direction):
          try:
              self.pos = self.house.MAP[self.pos.move(direction)]
              print(self.pos.name, self.pos.get_coordnate())
              return None
          except AssertionError:
              x,y,z = self.pos.get_coordnate()

              if direction == "north":
                  y += 1
              if direction == "south":
                  y -= 1
              if direction == "east":
                  x += 1
              if direction == "west":
                  x -= 1

              try:
                  self.pos.bi_connect(direction, self.house.MAP[(x,y,z)])
                  self.pos = self.house.MAP[self.pos.move(direction)]
                  print(self.pos.name, self.pos.get_coordnate())
              except KeyError:

                  self.house.spawn_room((x,y,z),
					housemap.List_of_Rooms.pop())
                  self.house.MAP[(x,y,z)].set_coordnate((x,y,z))
                  self.house.MAP[(x,y,z)].set_edges()
                  self.pos.bi_connect(direction, self.house.MAP[(x,y,z)])
                  self.pos = self.house.MAP[self.pos.move(direction)]
                  print(self.pos.name, self.pos.get_coordnate())
                  return None
          except KeyError:
              print("Invaild direction!")
              print(self.pos.name, self.pos.get_coordnate())
              return None

      def quit(self):
          sys.exit()


  if __name__ == '__main__':
      me = player(house)
      me.repl()
#+END_SRC

